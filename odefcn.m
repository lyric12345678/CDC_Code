function dxdt = odefcn(t,x)
global u_save
dxdt = zeros(3,1);
% Note that [x(1) x(2) x(3)]==[v_f v_l D]
% time
t
[Init_Par]=Initial_Parameter();
Init_Par.F_r=Init_Par.f_0+Init_Par.f_1*x(1)+Init_Par.f_2*(x(1))^2;% Rolling resistance (force)

%% Three different types of constraints
%% Hard Constraints
%These represent constraints that must not be violated under any condition.
%For ACC, this is simply the constraint: "keep a safe distance from the car
%infront of you". To guarantee the above specification, we use the condition:
%the minimum distance between two cars is "half the speedometer". This
%translate into the hard constraint: D>=tau_d*v (where tau_d is the desired
%time headway). h_safe=D-tau_d*v_f;
h_safe=x(3)-Init_Par.tau_d*x(1);
% if h_safe<0
%     x=x_save(:,end-1);
%     x_save(:,end)=[];
%     u_save(:,end)=[];
%     Init_Par.gamma=0;
%     h_safe=0;
% else
%     Init_Par.gamma=1;
% end


% n_par=2;
% if h_safe<0
%     Inner_state=x_save(:,end-1);
%     Outer_state=x_save(:,end);
%     cvx_begin quiet
%     variable lambda(n_par,1)
%     minimize(lambda.'*lambda)
%     subject to
%         (lambda(1)*Inner_state(3)+lambda(2)*Outer_state(3))-Init_Par.tau_d*(lambda(1)*Inner_state(1)+lambda(2)*Outer_state(1))<=1e-2;
%         (lambda(1)*Inner_state(3)+lambda(2)*Outer_state(3))-Init_Par.tau_d*(lambda(1)*Inner_state(1)+lambda(2)*Outer_state(1))>=0;
%         abs(lambda(1)+lambda(2)-1)<=1e-2;
%     cvx_end
%     x=lambda(1)*Inner_state+lambda(2)*Outer_state;
% end


%% Soft Constraints
% In the context of ACC, when adequate headway is assured, the goal is to
% achieve a desired speed, v_d. In other words, we expect
% lim_{t\rightarrow\infty}v_f(t)=v_d. This translates into a soft
% constraint can be written
% h_goal=(x(1)-Init_Par.v_d)^2;
h_goal=(x(1)-Init_Par.v_d)^2;

% %% Force Constraints
% % Note that the descriptions of this type of constraints can be found in paper
% % "Control Barrier Function based Quadratic Programs with Application to Adaptive Cruise Control"
% % These Constraints describe allowable wheel forces that are consistent with the driver convenience
% % aspect of ACC; these are typically much less than the peak forces that can be generated by the car
% % in emergency situations. Supposing that we do not want to accelerate or decelerate mote than some
% % fraction of g, we can write the constraints on acceleration and deceleration as an inequality:
% % -c_d*g<=F_w/m<=c_a*g; Basically, this inequality is equivalent to
% % -u_min<=u<=u_max in our formulation. Specifically, u_min=c_d*g*M, and we
% % deine c_d=0.25, g=9.81 and M=1650 in Initial_Parameter.m
% u>=-u_max;u<=u_max;



%% Formulate the Universal Formula
Lf_goal=-2*(x(1)-Init_Par.v_d)*(Init_Par.F_r)/Init_Par.M;
Lg_goal=2*(x(1)-Init_Par.v_d)/Init_Par.M;
Lf_hS = x(2)-x(1)+Init_Par.tau_d*Init_Par.F_r/Init_Par.M;
Lg_hS = -Init_Par.tau_d/Init_Par.M;
b_x=Lg_goal*Init_Par.M;
d_x=Lg_hS*Init_Par.M;
aaa_x=Lf_goal+Lg_goal*Init_Par.F_r;
ccc_x=Lf_hS+Lg_hS*Init_Par.F_r;
phi_x=(16*h_goal^2-aaa_x^2)/(b_x^2);
var_phi_x=(0.25*h_safe^2-ccc_x^2)/(d_x^2);
m_x=sqrt(aaa_x^2+phi_x*b_x^2);
n_x=sqrt(ccc_x^2+var_phi_x*d_x^2);


% m_x=4*h_goal;
% n_x=0.5*h_safe;

a_x=aaa_x+m_x;
c_x=ccc_x+n_x;
% 
% k_clf=-a_x/(b_x^2+1/Init_Par.p_sc)*b_x;
% k_cbf=-c_x/d_x;

% a_x=Lf_goal+4*h_goal+Lg_goal*Init_Par.F_r;
% c_x=Lf_hS+0.5*h_safe+Lg_hS*Init_Par.F_r;

k_clf=-a_x/(b_x^2+1/Init_Par.p_sc)*b_x;
k_cbf=-c_x/d_x;


w_x=a_x*d_x*d_x-c_x*b_x*d_x;
v_x=a_x*d_x*b_x-c_x*(1/Init_Par.p_sc+b_x*b_x);
R_x_bar=[1/Init_Par.p_sc+b_x*b_x,-b_x*d_x;-b_x*d_x,d_x*d_x];

lamda_bar=inv(R_x_bar)*[a_x;-c_x];
lamda_bar_1=lamda_bar(1);
lamda_bar_2=lamda_bar(2);
gamma_bar_1=-lamda_bar_1*b_x/k_clf;
gamma_bar_2=-lamda_bar_2*b_x/k_cbf;

% if a_x<0 && c_x>0
%     u=0;
% end
% if a_x<0 && abs(c_x)<0.01 && abs(d_x)<0.01
%     u=0;
% end

%% Domain of sets
if c_x<=0 && w_x<0
   u=k_cbf; 
end

if a_x>=0 && v_x<0
   u=k_clf; 
end

if a_x>=0 && abs(c_x)<0.01 && abs(d_x)<0.01
    u=k_clf; 
end

if w_x>=0 && v_x>=0
%    u= gamma_bar_2*k_cbf-gamma_bar_1*k_clf;
u=-lamda_bar_1*b_x+lamda_bar_2*d_x;
end
u=u*Init_Par.M+Init_Par.F_r;
u_save=[u_save,u];


% A=[Lg_goal,-1;-Lg_hS,0];
% b=[-Lf_goal-Init_Par.c_convergence_rate*h_goal,Lf_hS+Init_Par.gamma*h_safe].';
% % A=[Lg_goal,-1;-Lg_hS,0];
% % b=[-Lf_goal-Init_Par.c_convergence_rate*h_goal,Lf_hS].';
% H=2*[1/(Init_Par.M^2),0;0,Init_Par.p_sc];
% F=-2*[Init_Par.F_r/(Init_Par.M^2),0].';
% [u_qp]=quadprog(H,F,A,b);
% u_save=[u_save,u_qp(1)];
% 
% % if abs(u_qp-u)>1
% %     m=1;
% % end




% a_L=0;
%Store the generated control input
% %% Define the acceleration of the leading vehicle
if t<=8
    a_L = 0;
elseif t<=18
    a_L = 1.2;
elseif t<=30
    a_L = 0;
elseif t<=40
    a_L = 0.5;
elseif t<=50
    a_L = 0;
elseif t<=60
    a_L = -1;
else
    a_L = 0;
end

%% Dynamics of the system
dxdt(1)=-Init_Par.F_r/Init_Par.M+u(1)/Init_Par.M;                           %Note that u is essentially the wheel force
dxdt(2)=a_L;
dxdt(3)=x(2)-x(1);
end